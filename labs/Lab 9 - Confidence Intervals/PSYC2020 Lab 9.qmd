---
title: "Confidence Intervals"
subtitle: "PSYC 2020-A01 / PSYC 6022-A01 | 2025-10-17 | Lab 9"
author: "Jessica Helmer"
format: 
  live-revealjs:
    slide-number: true
    show-slide-number: all
    css: PSYC2020L_styles.css
engine: knitr
webr:
  packages:
    - rio
    - datasets
execute:
  echo: true
width: 1200
cache: true
---

## Outline

* Assignment 8 Review
* Confidence Intervals
* One-Sample *t*-test

Learning objectives:  
**R:** CI and *t*-statistics in R

```{r, echo =F}
library(tidyverse)
```


## Assignment 8 Review

Two ways to approach two-tailed p-values

:::: {.columns style="font-size:80%"}
::: column
Conceptually: split your alpha onto either side of the distribution

Technically test each side (both positive and negative cutoff), but know that e.g., negative *z*-value isn't going to beat the positive cutoff

Compare against split alpha (2.5%, *p* = .025) on either side.

```{r}
pnorm(-1.7)
```

[Fine for just reject / retain decisions (if compare it against correct alpha)]{.fragment}
:::

::: column
To report the *p*-value specifically for the entire test, would need to multiply by 2.

```{r}
pnorm(-1.7)*2
```
Account for probability of being more extreme in both directions
:::
::::


## Assignment 8 Review 

Remember to check the correct tail of the distribution

```{r}
#| layout-ncol: 3
#| fig-width: 4
#| fig-height: 3.5
#| echo: false
dat <- data.frame(x = seq(-5, 5, length.out = 1000),
                  y = dnorm(seq(-5, 5, length.out = 1000), 0, 1))

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < -1.67), aes(x = x, y = y), fill = 'salmon', alpha = .8) +
  geom_line() +
  annotate("text", x = -4.7, y = .38, label = paste0("pnorm(-1.67) = ", round(pnorm(-1.67), 2)),
           hjust = 0) +
  coord_cartesian(expand = F) +
  guides(y = "none") +
  labs(y = NULL) +
  theme_classic(base_size = 16)

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < 0), aes(x = x, y = y), fill = 'salmon', alpha = .8) +
  geom_line() +
  annotate("text", x = -4.7, y = .38, label = paste0("pnorm(0) = ", round(pnorm(0), 2)),
           hjust = 0) +
  coord_cartesian(expand = F) +
  guides(y = "none") +
  labs(y = NULL) +
  theme_classic(base_size = 16)

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < 1.67), aes(x = x, y = y), fill = 'salmon', alpha = .8) +
  geom_line() +
  annotate("text", x = -4.7, y = .38, label = paste0("pnorm(1.67) = ", round(pnorm(1.67), 2)),
           hjust = 0) +
  annotate("text", x = -4.7, y = .35, label = paste0("pnorm(1.67, lower.tail=F) = ", round(pnorm(1.67, lower.tail = F), 2)),
           hjust = 0) +
  coord_cartesian(expand = F) +
  guides(y = "none") +
  labs(y = NULL) +
  theme_classic(base_size = 16)
```



# Confidence Intervals


## Confidence Intervals

Most common: 95% CI

<div class="subsubpoint">○ Interpretation: If you were to take 100 samples, 95 CIs of your 100 samples will contain the true mean </div>

For standard normal,

| CI    | *z* cutoff    | generally                                |
|-------|---------------|------------------------------------------|
| 99.7% | [-3, 3]       | [$\bar{x} - 3 * SD$, $\bar{x} + 3 * SD$] |
| 95%   | [-1.96, 1.96] | [$\bar{x} - 1.96 * SD$, $\bar{x} + 1.96 * SD$] |
| 68%   | [-1, 1]       | [$\bar{x} - 1 * SD$, $\bar{x} + 1 * SD$] |


## Confidence Interval and Width

Confidence Level ($1 - \alpha$) can communicate uncertainty about your results

<div class="subpoint">○ Designated proportion of such intervals that will include the true population value </div>

<div class="subsubpoint">○ $\alpha =$ 0.01 for 99% CI </div>

<div class="subsubpoint">○ $\alpha =$ 0.05 for 95% CI </div>

:::: columns
::: {.column width=35%}
Confidence level proportional to confidence interval width
:::

::: {.column width=65%}
:::
::::

![](https://stats.libretexts.org/@api/deki/files/850/standard_deviation.png?revision=1&size=bestfit&width=784&height=398){.absolute bottom=0 right=0}


## CIs for Symmetric Distributions

When a distribution is symmetric, CIs for that distribution are also symmetric

<div class="subpoint">○ Includes normal (e.g., *z*-) distribution </div>

<div class="subpoint">○ *t* distribution </div>

![](https://miro.medium.com/v2/resize:fit:1400/1*Mk6EV8oIB1jlbQWcRzNRdg.png)


## Cutoff *Z*-Values Example

Say you want to find the cutoff *z* values for some confidence interval

Two examples: 95% CI and 97.3% CI (one typical, one as exercise)

::: fragment
We want the $\alpha = 1 -$ confidence level piece to be equal on both sides
:::

:::: {.columns .fragment style="font-size:80%"}
::: column
#### 95% CI

$\alpha = 1 - .95 = 5\%$ on both sides 

So $.05 / 2 = .025$ on each side

Need value for $.025$ and $.95 + .025$ ($[.025, .975]$)
```{r}
qnorm(c(.025, .975))
```
:::

::: column
#### 97.3% CI

$\alpha = 1 - .973 = 2.7\%$ on both sides 

So $.027 / 2 = .0135$ on each side

Need value for $.0135$ and $.95 + .0135$ ($[.0135, .9865]$)
```{r}
qnorm(c(.0135, 0.9865))
```
:::
::::

::: fragment
Which one has a higher confidence level? Which one has a larger width?
:::


## Cutoff *Z*-Values Example

::: panel-tabset
### Plot
```{r}
#| echo: false
#| fig-width: 9
#| fig-height: 4
#| fig-align: center
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(y = dnorm(x)) |>
  ggplot(aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "skyblue3") +
  annotate("errorbar", xmin = qnorm(c((1 - .973) / 2)), xmax = qnorm((1 - .973) / 2 + .973),
           y = .48, width = .02) +
  annotate("text", label = "97.3%", y = .48, x = 0, vjust = -.3, size = 6) +
  annotate("errorbar", xmin = qnorm(c((1 - .95) / 2)), xmax = qnorm((1 - .95) / 2 + .95),
           y = .42, width = .02) +
  annotate("text", label = "95%", y = .42, x = 0, vjust = -.3, size = 6) +
  scale_x_continuous(breaks = c(qnorm(c((1 - .973) / 2)), qnorm(c((1 - .95) / 2)),
                                0, 
                                qnorm(c((1 - .95) / 2) + .95), qnorm((1 - .973) / 2 + .973)) |>
                       round(2)) +
  coord_cartesian(clip = "off", ylim = c(0, .5), xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 12) +
  theme(axis.text.x = element_text(angle = 30))
```

### Code
```{r}
#| eval: false
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(y = dnorm(x)) |>
  ggplot(aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "skyblue3") +
  annotate("errorbar", xmin = qnorm(c((1 - .973) / 2)), xmax = qnorm((1 - .973) / 2 + .973),
           y = .48, width = .02) +
  annotate("text", label = "97.3%", y = .48, x = 0, vjust = -.3, size = 6) +
  annotate("errorbar", xmin = qnorm(c((1 - .95) / 2)), xmax = qnorm((1 - .95) / 2 + .95),
           y = .42, width = .02) +
  annotate("text", label = "95%", y = .42, x = 0, vjust = -.3, size = 6) +
  scale_x_continuous(breaks = c(qnorm(c((1 - .973) / 2)), qnorm(c((1 - .95) / 2)),
                                0, 
                                qnorm(c((1 - .95) / 2) + .95), qnorm((1 - .973) / 2 + .973)) |>
                       round(2)) +
  coord_cartesian(clip = "off", ylim = c(0, .5), xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 10) +
  theme(axis.text.x = element_text(angle = 30)) 
```
:::


## Confidence Interval Generally

Derived with sample mean ($\bar{x}$) and standard error ($\frac{s}{\sqrt n}$)

$CI = \bar{x} \pm z \frac{s}{\sqrt n}$ or

$CI = [\bar{x} - z \frac{s}{\sqrt n}, \bar{x} + z \frac{s}{\sqrt n}]$

::: callout-note
## Food for Thought

With this formula, we would only use the positive version of the *z* cutoff, so that the lower bound ends up lower than the mean and the higher bound ends up higher. You can also think instead as both adding the *z* cutoff---it just ends up becoming a minus sign because the lower bound has a negative *z* cutoff.
:::


## Confidence Interval Example

Let's find a 95% confidence interval of the mean for iris Petal Length

::: fragment
```{r}
head(iris$Petal.Length)

x_bar <- mean(iris$Petal.Length)
x_sd <- sd(iris$Petal.Length)
n <- length(iris$Petal.Length) # although remember to be thinking about missing data

z_cutoff <- qnorm(.975)

Petal.Length.CI <- c(x_bar - z_cutoff * x_sd / sqrt(n), x_bar + z_cutoff * x_sd / sqrt(n))
Petal.Length.CI
```
:::

[If we collected samples of petal length many times, we would expect the interval [3.47, 4.04] to contain the true population mean of petal length 95% of the time.]{.fragment}


## Confidence Interval Example

Let's find a 80% confidence interval of the mean for iris Sepal Length

::: fragment
```{r}
head(iris$Sepal.Length)

Sepal.Length.CI <- c(mean(iris$Sepal.Length) - qnorm(.9) * sd(iris$Sepal.Length) /
                       sqrt(sum(!is.na(iris$Sepal.Length))),
                     
                     mean(iris$Sepal.Length) + qnorm(.9) * sd(iris$Sepal.Length) /
                       sqrt(sum(!is.na(iris$Sepal.Length))))
Sepal.Length.CI
```
:::

[If we collected samples of sepal length many times, we would expect the interval [3.57, 3.94] to contain the true population mean of petal length 80% of the time.]{.fragment}


## Confidence Intervals and NHST

If a 95% confidence interval does not contain a value, that is mathematically equivalent to it being "significantly different" from that value.

E.g., if your null hypothesis $H_0$ was that the mean of petal length is no different from an expected population mean of 3.3, would you reject or retain the null hypothesis?

```{r}
Petal.Length.CI
```

[We would reject the null hypothesis because the 95% CI does not include 3.3.]{.fragment}


# From *Z* to *T*: No longer normal


## *Z*- vs. *T*-Distribution

*T*-distribution has thicker tails

As df increases, it looks more like a standard normal distribution

With df = $\infty$, exactly follows a normal distribution (so approximates with large df)


## *Z*- vs. *T*-Distribution

```{r}
#| echo: false
#| fig-align: center
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(normal = dnorm(x),
         t1 = dt(x, 1),
         t2 = dt(x, 2),
         t5 = dt(x, 5),
         t10 = dt(x, 10)) |>
  ggplot(aes(x = x)) +
  geomtextpath::geom_textline(aes(y = normal, label = "standard normal"),
                              hjust = .1, size = 6, linewidth = 1.5, color = "gray60") +
  coord_cartesian(clip = "off", xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 16) 
```


## *Z*- vs. *T*-Distribution

```{r}
#| echo: false
#| fig-align: center
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(normal = dnorm(x),
         t1 = dt(x, 1),
         t2 = dt(x, 2),
         t5 = dt(x, 5),
         t10 = dt(x, 10)) |>
  ggplot(aes(x = x)) +
  geomtextpath::geom_textline(aes(y = normal, label = "standard normal"),
                              hjust = .1, size = 6, linewidth = 1.5, color = "gray60") +
  geomtextpath::geom_textline(aes(y = t1, label = "t(df=1)"),
                              hjust = .28, size = 6, linewidth = 1.5, color = "skyblue") +
  coord_cartesian(clip = "off", xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 16) 
```

## *Z*- vs. *T*-Distribution

```{r}
#| echo: false
#| fig-align: center
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(normal = dnorm(x),
         t1 = dt(x, 1),
         t2 = dt(x, 2),
         t5 = dt(x, 5),
         t10 = dt(x, 10)) |>
  ggplot(aes(x = x)) +
  geomtextpath::geom_textline(aes(y = normal, label = "standard normal"),
                              hjust = .1, size = 6, linewidth = 1.5, color = "gray60") +
  geomtextpath::geom_textline(aes(y = t1, label = "t(df=1)"),
                              hjust = .28, size = 6, linewidth = 1.5, color = "skyblue") +
  geomtextpath::geom_textline(aes(y = t2, label = "t(df=2)"),
                              hjust = .35, size = 6, linewidth = 1.5, color = "steelblue") +
  coord_cartesian(clip = "off", xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 16) 
```


## *Z*- vs. *T*-Distribution

```{r}
#| echo: false
#| fig-align: center
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(normal = dnorm(x),
         t1 = dt(x, 1),
         t2 = dt(x, 2),
         t5 = dt(x, 5),
         t10 = dt(x, 10)) |>
  ggplot(aes(x = x)) +
  geomtextpath::geom_textline(aes(y = normal, label = "standard normal"),
                              hjust = .1, size = 6, linewidth = 1.5, color = "gray60") +
  geomtextpath::geom_textline(aes(y = t1, label = "t(df=1)"),
                              hjust = .28, size = 6, linewidth = 1.5, color = "skyblue") +
  geomtextpath::geom_textline(aes(y = t2, label = "t(df=2)"),
                              hjust = .35, size = 6, linewidth = 1.5, color = "steelblue") +
  geomtextpath::geom_textline(aes(y = t10, label = "t(df=10)"), 
                            hjust = .4, size = 6, linewidth = 1.5, color = "steelblue4") +
  coord_cartesian(clip = "off", xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 16) 
```


## *Z*- vs. *T*-Distribution

```{r}
#| echo: false
#| fig-align: center
data.frame(x = seq(-5, 5, length.out = 1000)) |>
  mutate(normal = dnorm(x),
         t1 = dt(x, 1),
         t2 = dt(x, 2),
         t5 = dt(x, 5),
         t10 = dt(x, 10),
         t100 = dt(x, 100)) |>
  ggplot(aes(x = x)) +
  geomtextpath::geom_textline(aes(y = normal, label = "standard normal"),
                              hjust = .1, size = 6, linewidth = 1.5, color = "gray60") +
  geomtextpath::geom_textline(aes(y = t1, label = "t(df=1)"),
                              hjust = .28, size = 6, linewidth = 1.5, color = "skyblue") +
  geomtextpath::geom_textline(aes(y = t2, label = "t(df=2)"),
                              hjust = .35, size = 6, linewidth = 1.5, color = "steelblue") +
  geomtextpath::geom_textline(aes(y = t10, label = "t(df=10)"), 
                            hjust = .4, size = 6, linewidth = 1.5, color = "steelblue4") +
  geomtextpath::geom_textline(aes(y = t100, label = "t(df=100)"), 
                            hjust = .48, size = 6, linewidth = 1.5, color = "royalblue4") +
  coord_cartesian(clip = "off", xlim = c(-5, 5), expand = F) +
  guides(y = "none") +
  labs(x = NULL, y = NULL) +
  theme_classic(base_size = 16) 
```


## *T*-Test: How many tails?

Need to consider whether to use a "one-tail" or "two-tail" *t*-test.

:::: columns
::: {.column}
#### One-Tail (One-Sided)

We want to test whether something is lower or higher than a value, but **not both**

Only one limit
:::

::: {.column}
#### Two-Tails (Two-Sided)

We want to test whether something is either lower or higher than a value

Two limits
:::
::::


## Testing: How many tails?

Need to consider whether to use a "one-tail" or "two-tail" *t*-test.

:::: columns
::: {.column}
#### One-Tail (One-Sided)

```{r}
#| echo: false
#| fig-width: 3.5
#| fig-height: 3.5
#| fig-align: center
dat <- data.frame(x = seq(-5, 5, length.out = 1000)) |>
                  mutate(y = dnorm(x, 0, 1))

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < qnorm(.05)), aes(x = x, y = y), fill = 'salmon', alpha = .8) +
  geom_line() +
  geomtextpath::geom_textline(aes(label = "5%"),
                              hjust = .12, vjust = 0, size = 8, color = "salmon", linewidth = NA) +
  annotate("text", label = "Lower tail test", x = -5, y = .38, hjust = 0) +
  coord_cartesian(expand = F, clip = "off") +
  guides(y = "none") +
  labs(y = NULL, x = NULL) +
  theme_classic(base_size = 16)
```
:::

::: {.column}
#### Two-Tails (Two-Sided)

```{r}
#| echo: false
#| fig-width: 3.5
#| fig-height: 3.5
#| fig-align: center
dat <- data.frame(x = seq(-5, 5, length.out = 1000)) |>
                  mutate(y = dnorm(x, 0, 1))

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < qnorm(.025)), aes(x = x, y = y), fill = 'salmon', alpha = .8) +
  geom_area(data = dat |> filter(x > qnorm(.975)), aes(x = x, y = y), fill = 'salmon', alpha = .8) +
  geom_line() +
  geomtextpath::geom_textline(aes(label = "2.5%"),
                              hjust = .12, vjust = 0, size = 8, color = "salmon", linewidth = NA) +
  geomtextpath::geom_textline(aes(label = "2.5%"),
                              hjust = .88, vjust = 0, size = 8, color = "salmon", linewidth = NA) +
  coord_cartesian(expand = F) +
  guides(y = "none", clip = "off") +
  labs(y = NULL, x = NULL) +
  theme_classic(base_size = 16)
```
:::
::::


## Testing: How many tails?

Notice that two-tailed tests are harder to "beat."

```{r}
#| echo: false
#| fig-width: 8.5
#| fig-height: 3
#| fig-align: center
dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < qnorm(.05)), aes(x = x, y = y), fill = 'salmon', alpha = .5) +
  geom_area(data = dat |> filter(x < qnorm(.025)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_area(data = dat |> filter(x > qnorm(.975)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_line() +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.025), label = "2.5% cutoff"),
                              hjust = .15, size = 6, color = "skyblue3", linewidth = 1.5) +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.05), label = "5% cutoff"),
                              hjust = .85, size = 6, color = "salmon", linewidth = 1.5) +
  scale_x_continuous(breaks = round(c(qnorm(.025), qnorm(.05), 0, qnorm(.975)), 2)) +
  coord_cartesian(expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL) +
  theme_classic(base_size = 10)
```


## Cutoff *T*-Values Example

Say you want to find the cutoff *t* values: t(df = 3) and t(df = 37) for $\alpha = .05$, want both upper one-tailed and two-tailed

::: fragment
Which will have the larger magnitude cutoff values?
:::

:::: {.columns .fragment style="font-size:70%"}
::: column
**One-Tailed**

All of our $\alpha = .05$ goes on the upper side

Need a cutoff for $.95$
```{r}
qt(p = .95, df = 3)

qt(p = .05, df = 37, lower.tail = F)
```
$t_{crit}(3) = 2.35$

$t_{crit}(37) = 1.69$
:::

::: column
**Two-Tailed**

$\alpha = 1 - .95 = 5\%$ on both sides 

So $.05 / 2 = .025$ on each side

Need value for $.025$ and $.95 + .025$ ($[.025, .975]$)
```{r}
qt(p = c(.025, .975), df = 3)

qt(p = c(.025, .975), df = 37)
```
$t_{crit}(3) = [-3.18, 3.18]$

$t_{crit}(37) = [-2.03, 2.06]$
:::
::::


## One-Sample *T*-Test Generally

Asks "is there a question between our sample and the population?"

Derived with sample mean ($\bar{x}$), population mean ($\mu$), and standard error ($\frac{s}{\sqrt n}$)

$$t = \frac{\bar{x} - \mu}{\frac{s}{\sqrt{n}}}$$

With a *t*-test, we don't have a known population SD ($\sigma$), so we use the SD we observe in our sample $s$

Get our *t*-statistic and compare it to a critical *t* cutoff value


## *T*-Test Example

Let's say a researcher claims the average highway miles per gallon across all cars is 30mpg. They collect a sample of 234 cars and would like you to test this. We do not know the population standard deviation.

::: fragment
One- or two-tailed?
:::

:::: {.columns style="font-size:80%"}
::: {.column .fragment width="75%"}
```{r}
head(mpg$hwy)

x_bar <- mean(mpg$hwy)
x_sd <- sd(mpg$hwy)
n <- length(mpg$hwy) # although remember to be thinking about missing data
df <- n - 1

t_cutoff <- qt(.975, df)

hwy_t_stat <- (x_bar - 30) / (x_sd / sqrt(n))
hwy_t_stat
```
:::

::: {.column width="25%"}
[Our observed *t*-statistic exceeds our cutoff *t*-statistic, so we reject the null.]{.fragment}
:::
::::


## *T*-Test Function

Alternatively, we can use `t.test(x)`

<div class="subpoint">○ `x` = vector of numeric data </div>

<div class="subpoint">○ `mu` = hypothesized population mean (default is 0) </div>

<div class="subpoint">○ `alternative` = one of `"two.sided"`, `"less"`, `"greater"` (default is `"two.sided"`) </div>

:::: {.columns style="font-size:80%"}
::: {.column .fragment width="75%"}
```{r}
#| code-line-numbers: false
t.test(mpg$hwy, mu = 30, alternative = "two.sided")
```
:::

::: {.column width="25%"}
[We see a significant difference between our observed sample mean and our hypothesized population mean.]{.fragment}
:::
::::


## *T*-Test Example

Let's say a different researcher claims the average **city** miles per gallon across all cars is 30mpg. They collect a sample of 234 cars You are confident they are wrong---you think it is certainly less than that. We do not know the population standard deviation.

::: fragment
One- or two-tailed?
:::

:::: {.columns style="font-size:80%"}
::: {.column .fragment width="75%"}
```{r}
t.test(mpg$cty, mu = 30, alternative = "less")
```
:::
::: {.column width="25%"}
[We see a significant difference between our observed sample mean and our hypothesized population mean.]{.fragment}
:::
::::


## *T*-Test Example Output

:::: {.columns}
::: column
```{r}
hwy_ttest <- t.test(mpg$cty, mu = 30)
hwy_ttest

#?t.test
```
:::

::: column
```{r}
hwy_ttest$statistic
hwy_ttest$p.value
```

::: fragment
```{r}
hwy_ttest$conf.int
```
:::
:::
::::

Can use these in RMarkdown documents with inline R chunks.


## *T*-Tests and Confidence Intervals

The `t.test()` function includes a CI value! But...

:::: {.columns .fragment}
::: column
```{r}
#| code-line-numbers: false
t.test(mpg$cty, mu = 30) |> 
  pluck("conf.int") |> 
  c()
```
:::

::: column
```{r}
#| code-line-numbers: false
c(mean(mpg$cty) - qnorm(.975) * sd(mpg$cty) /
    sqrt(sum(!is.na(mpg$cty))),
  
  mean(mpg$cty) + qnorm(.975) * sd(mpg$cty) /
    sqrt(sum(!is.na(mpg$cty))))
```
:::
::::

[They're not the same!]{.fragment}

[The built-in functions in R for confidence intervals in R often follow a *t*-distribution instead of a *z*-distribution. We want the *z*-distribution in our class, but as we saw, the differences will be very small for large samples.]{.fragment}


## Testing and NHST

Remember, even when the statistic is small, for two-tailed tests (because negative), we reject when we exceed the bounds of our critical value.

For one-tailed tests, it needs to exceed the bound of that tail's cutoff.

::: fragment

Reject or retain null?

```{r}
#| echo: false
#| fig-width: 4
#| fig-height: 3
#| layout-ncol: 3
dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < qnorm(.025)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_area(data = dat |> filter(x > qnorm(.975)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_line() +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.025), label = "2.5% cutoff"),
                              hjust = .5, size = 6, color = "skyblue3", linewidth = 1.5) +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.975), label = "2.5% cutoff"),
                              hjust = .5, size = 6, color = "skyblue3", linewidth = 1.5) +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.001), label = "observed t-stat"),
                              hjust = .5, size = 6, color = "gray", linewidth = 1.5) +
  scale_x_continuous(breaks = round(c(qnorm(.001), qnorm(.025), 0, qnorm(.975)), 2)) +
  coord_cartesian(expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL) +
  theme_classic(base_size = 12)

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < qnorm(.025)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_area(data = dat |> filter(x > qnorm(.975)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_line() +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.025), label = "2.5% cutoff"),
                              hjust = .5, size = 6, color = "skyblue3", linewidth = 1.5) +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.975), label = "2.5% cutoff"),
                              hjust = .5, size = 6, color = "skyblue3", linewidth = 1.5) +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.2), label = "observed t-stat"),
                              hjust = .5, size = 6, color = "gray", linewidth = 1.5) +
  scale_x_continuous(breaks = round(c(qnorm(.2), qnorm(.025), 0, qnorm(.975)), 2)) +
  coord_cartesian(expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL) +
  theme_classic(base_size = 12)

dat |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = dat |> filter(x < qnorm(.05)), aes(x = x, y = y), fill = 'skyblue3', alpha = .6) +
  geom_line() +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.05), label = "5% cutoff"),
                              hjust = .5, size = 6, color = "skyblue3", linewidth = 1.5) +
  geomtextpath::geom_textvline(aes(xintercept = qnorm(.99999), label = "observed t-stat"),
                              hjust = .5, size = 6, color = "gray", linewidth = 1.5) +
  scale_x_continuous(breaks = round(c(qnorm(.99999), qnorm(.025), 0, qnorm(.975)), 2)) +
  coord_cartesian(expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL) +
  theme_classic(base_size = 12)
```
:::


## Cohen's *D*

Standardized mean difference, interpretable effect size

Derived with two means (represented as $\mu_1$ and $\mu_2$) and standard deviation ($s$)

$$d = \frac{\mu_1 - \mu_2}{s}$$

For a one-sample *t* test, $\mu_1$ would be our sample mean $\bar{x}$, $\mu_2$ would be our population mean $\mu$, and the standard deviation $\sigma$ would be our observed standard deviation $s$.

Not a statistical test---just a measure of difference.


## Cohen's *D* Example

Let's say a researcher claims the average highway miles per gallon across all cars is 30mpg. We found earlier that the sample had a significant difference between the hypothesized and sample mean. What is the effect size of that difference?

$$d = \frac{\bar{x} - \mu}{s}$$

::: fragment
```{r}
x_bar <- mean(mpg$hwy)
x_sd <- sd(mpg$hwy)

d <- (x_bar - 30) / x_sd
d
```
:::

[How would be characterize this difference? What is the direction?]{.fragment}


## Cohen's *D* Strength Visualization

Based on mean ($\bar{x}$ = `round(x_bar, 2)` = `r round(x_bar, 2)`) and SD ($\bar{\sigma}$ = `round(x_sd, 2)` = `r round(x_sd, 2)`) of cars' highway MPG (`hwy`).

Solved backwards for ($\mu$) based on different potential levels of *d*. "What would the hypothesized mean have to have been to get different levels of Cohen's *d*?"

$$\bar{x} - d \times s = \mu$$

```{r}
dat <- data.frame(x = rnorm(100000, x_bar, x_sd))

mu_ex1 <- x_bar - .2 * x_sd
mu_ex2 <- x_bar - .5 * x_sd
mu_ex3 <- x_bar - .8 * x_sd
```


## Cohen's *D* Strength Visualization

"What would the hypothesized mean have to have been to get different levels of Cohen's *d*?"

```{r}
#| echo: false
#| fig-width: 5
#| fig-height: 4
#| fig-align: center
ggplot(dat, aes(x = x)) +
  geom_histogram(fill = 'skyblue3', alpha = .4, bins = 16) +
  geom_vline(aes(xintercept = x_bar),
             color = "skyblue3", linewidth = 1, linetype = "dashed") +
  coord_cartesian(xlim = c(0, 60), expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL, x = "Highway MPG") +
  theme_classic(base_size = 18)
```


## Cohen's *D* Strength Visualization

"What would the hypothesized mean have to have been to get different levels of Cohen's *d*?"


```{r}
#| echo: false
#| fig-width: 5
#| fig-height: 4
#| layout-ncol: 3
#| fig-align: center
ggplot(dat, aes(x = x)) +
  geom_histogram(fill = 'skyblue3', alpha = .4, bins = 16) +
  geom_vline(aes(xintercept = x_bar),
             color = "skyblue3", linewidth = 1, linetype = "dashed") +
  geomtextpath::geom_textvline(aes(xintercept = mu_ex1, label = "d = 0.2"),
                               hjust = .3, size = 10, color = "steelblue4", linewidth = 1.5) +
  coord_cartesian(xlim = c(0, 60), expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL, x = "Highway MPG") +
  theme_classic(base_size = 18)

ggplot(dat, aes(x = x)) +
  geom_histogram(fill = 'skyblue3', alpha = .4, bins = 16) +
  geom_vline(aes(xintercept = x_bar),
             color = "skyblue3", linewidth = 1, linetype = "dashed") +
  geomtextpath::geom_textvline(aes(xintercept = mu_ex2, label = "d = 0.5"),
                               hjust = .3, size = 10, color = "steelblue4", linewidth = 1.5) +
  coord_cartesian(xlim = c(0, 60), expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL, x = "Highway MPG") +
  theme_classic(base_size = 18)

ggplot(dat, aes(x = x)) +
  geom_histogram(fill = 'skyblue3', alpha = .4, bins = 16) +
  geom_vline(aes(xintercept = x_bar),
             color = "skyblue3", linewidth = 1, linetype = "dashed") +
  geomtextpath::geom_textvline(aes(xintercept = mu_ex3, label = "d = 0.8"),
                               hjust = .3, size = 10, color = "steelblue4", linewidth = 1.5) +
  coord_cartesian(xlim = c(0, 60), expand = F, clip = "off") +
  guides(y = "none", x = NULL) +
  labs(y = NULL, x = "Highway MPG") +
  theme_classic(base_size = 18)

```


## Cohen's *D* in R

There are functions for Cohen's *d* in R, but they apply more to two samples of means.
<div class="subpoint">○ Instead of one sample and a population mean </div>

For now, simpler to just program it ourselves `(x_bar - mu) / x_sd`

Two samples will come later!


## Assignment 9






